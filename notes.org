#+title: Notes

* Character Selection Screen
** Notable Bytes
- $1B40: Player One selected character
- $1B80: Player Two selected character
- $5C-$5D: Current frame input player one
- $5E-$5F: Current frame input player two
- $60-$61: New button presses player one
- $62-$63: New button presses player two
  $8a -> this is the current screen
  $8d -> the submenu (eg. $8a of 2 is CSS, 8D of 1 is vs, 2 vs cpu, 4 practice)
  $7e2000 -> the beginning of RAM and also where CHR data seems to be copied

** Character Codes
| Character | Value |
|-----------+-------|
| Moon      | $1    |
| Mercury   | $2    |
| Mars      | $3    |
| Jupiter   | $4    |
| Venus     | $5    |
| Uranus    | $6    |
| Neptune   | $7    |
| Pluto     | $8    |
| Chibi     | $9    |

** Notable Functions
- CSS_UPDATE_P1_CHAR
  On the CSS Screen, reads player one movement and sets the character code P1 is set to. Uses Character Selection Grid.
- C0EBFB handles sending audio data to APU.

* C0 Databanks
- Character Selection Grid
  Roughly C0AA51 - C0AA74
  4 byte chunks for each character. The chunks are:
  Up Down Left Right.

* Battle
** Notable Bytes
- 000a00 this seems to be one of several mirrored bytes that stores p1's position relative to the left side of the screen. $0 to $80
- $0803/$0804 contain the timer. It is in decimal, second then first
- $1001 seems to be p1 animation, changes based on frame but only when doing something goes up to 1300
  $0b00 looks worth looking into too
- $1d00 is p1 character, $1d03 is p2 character
  $1d02 is p1 character color
- At some point on load of scenes, 54 7f c0 6b 7f 7f 6b gets written to c8. this is a mvn opcode. :O 808dc9 writes to it on load. c01e83 on stage select
  MVN #$7F, #$C0
  RTL
  MVN #$7F, #$7F
  RTL

  JSR in instruction C3867c step over caused gong and tile viewer update
  83869A caused color palette update

  digging into one of the title screen updates, 80a23b is when we see it happen, but it was likely set before that as 80a21f onwards I see it manipulating data in $00 that I think it uses
  by the end of the function call at 80a278, it's updated the tileset to point at 4000 and is what we would expect it to look like. So The functions starting at 80a214 are our best bet to investigate further.

  - Potential breakpoints:
    83832E tiles load in this
    80A23B the start of the function where tiles load and then are corrected
    80A0DE top level, each time it runs we see a demo above and it reloads things

    4280 contains the beginning of the copyright part of the tilemap on title screen
    47a20 contains the top of chibi's head....so different places

    2180 set for BBAD1
    AT1 set to 808192
    DMAP1 set to 8 (decrement A bus address after copy) WRAM copy
    000808 is s-wram address
    1FEC
    8381D6

    source address: c36d30
    destination 7e2000
    A 7E
    X BEDA
    Y starting value doesn't matter

    1A is 2 bytes first time
    Each segment is 16 bytes.
    There is a 2 byte header, where each bit in theory can represent a byte. Bits are popped off one at a time. If it's 1, copy the byte directly.

    If it's 0, then it's describing a more complex pattern.
    0-1 appears to be a mass copy.

    ** Loads a word, HHLL. If the first 3 bits of HH are 0, it jumps to CODE_C09265. Otherwise the iteration count is 2+first 3 bits of HH.
    The top 5 bits are used to give a vector of where to pull from (current destination + vector, most commonly #$FF (-1)). LL is used for the low byte of the vector.

    With CODE_C09265, it reads in a byte. If that byte is 0, we're done.
    If it's 1, go back to loop. Not encountered in testing. Othrewise, 1+byte is the iteration count.

    When copying, 3 bytes are used:
    Direction byte:
    | 7 6 5 4 3 | 2 1 0 |
    | DIRECTION | ITER  |
        ITER:
        If iter is 1+, we iterate this +2 many with the smaller copy procedure.
        If iter is 0, Load the next byte, ITER_BYTE
        When the ITER_BYTE is 0:
            End the graphics compression
        When the ITER_BYTE is 1:
            Proceed to the top of the header (this probably should never happen)
        Greater than 1:
            ITER_BYTE+1 bytes are copied
        DIRECTION:
        These are used for the higher bits of the vector to adjust where we start copying from. This is relative to the destination, so $FFFF will start copying from the prior byte.
    Lower Direction byte:
    | 7 6 5 4 3 2 1 0 |
    | Lower Direction |
        Lower Direction:
        Combined with DIRECTION bits and some set 1s to form the vector:
        | 1 1 1 D D D D D | L L L L L L L L |
        This is added to the destination address in $03 to form the location to start copying bytes from. Each byte it pulls from the next one over.

        Neptune's hand background chunk is at the 40000 point in the rom.
